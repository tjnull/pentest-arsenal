$banner = @"

▄████████    ▄████████ ████████▄   ▄█   ▄████████  ▄█       ███    █▄     ▄████████
███    ███   ███    ███ ███   ▀███ ███  ███    ███ ███       ███    ███   ███    ███
███    █▀    ███    ███ ███    ███ ███▌ ███    █▀  ███       ███    ███   ███    █▀
███          ███    ███ ███    ███ ███▌ ███        ███       ███    ███   ███
███        ▀███████████ ███    ███ ███▌ ███        ███       ███    ███ ▀███████████
███    █▄    ███    ███ ███    ███ ███  ███    █▄  ███       ███    ███          ███
███    ███   ███    ███ ███   ▄███ ███  ███    ███ ███▌    ▄ ███    ███    ▄█    ███
████████▀    ███    █▀  ████████▀  █▀   ████████▀  █████▄▄██ ████████▀   ▄████████▀

                                     Version 1.0
                                     Created by: TJ Null

"@

# Print the ASCII banner
Write-Host $banner

# Function to display help if requested by the user
function Show-Help {
    $helpText = @"
General Guidelines:

A PowerShell Script that searches for possible paths to escalate privileges on Linux/Unix/MacOS hosts using PowerShell for Linux.

Available Command Options:
- Run-All
- Get-OSInfo
- Check-ADJoinStatus
- Get-Drives
- Get-NetworkActivity
- Get-LoggedInUsers
- Check-AVInstalled
- Check-CredentialManagerInstalled
- Search-PS1Files
- Search-AWSCredentials
- Search-AzureCredentials
- Review-UserHistory
- Review-PSHistory
- Check-Programs

Running Cadiclus:

Show me everything:
./cadiclus.ps1 Run-All
Show me certain information by running multiple commands:
./cadiclus.ps1 Get-OSInfo Get-Drives Check-AVInstalled

"@
    Write-Host $helpText
}

function Run-All {
    Write-Host "`n[+] Running all functions..."

    Get-OSInfo
    Check-ADJoinStatus
    Get-Drives
    Get-NetworkActivity
    Get-LoggedInUsers
    Check-AVInstalled
    Check-CredentialManagerInstalled
    Search-AWSCredentials
    Search-AzureCredentials
    Review-UserHistory
    Review-PSHistory
    Check-Programs

    Write-Host "`n[+] All functions executed."
}

# Define the function to get OS information and kernel version
function Get-OSInfo {
    $osInfo = [System.Runtime.InteropServices.RuntimeInformation]::OSDescription
    $osReleaseContent = Get-Content /etc/os-release
    $osRelease = @{ }
    foreach ($line in $osReleaseContent) {
        if ($line -match '^(.+?)=(.+)$') {
            $key = $matches[1]
            $value = $matches[2].Trim('"')
            $osRelease[$key] = $value
        }
    }

    Write-Host "`n[+] Operating System Kernel Version:"
    Write-Host $osInfo
    Write-Host "`n[+] OS Release Information:"
    foreach ($key in $osRelease.Keys) {
        Write-Host "$key = $($osRelease[$key])"
    }
}

# Define the function to check if the system is joined to a domain controller
function Check-ADJoinStatus {
    Write-Host "`n[+] Checking if the system is joined to an Active Directory domain..."

    if (Test-Path "$(which realm)") {
        $adStatus = realm list | Select-String -Pattern 'domain-name'

        if ($adStatus) {
            Write-Host "The system is joined to an Active Directory domain."
        } else {
            Write-Host "The system is not joined to an Active Directory domain."
        }
    } else {
        Write-Host "The 'realm' command is not installed on this system."
    }
}

# Define the function to check for local and network drives
function Get-Drives {
    $drives = Get-PSDrive
    Write-Host "`n[+] List of Local and Network Drives:"
    $drives | Format-Table -AutoSize Name, @{Label="Provider";Expression={$_.Provider}}, Root, 
        @{Label="Used (GB)";Expression={[math]::round($_.Used/1GB,2)}}, 
        @{Label="Free (GB)";Expression={[math]::round($_.Free/1GB,2)}}
}

# Define the function to check for current network connections
function Get-NetworkActivity {
    Write-Host "`n[+] Grabbing current network connections..."
    $networkActivity = ss -ntlp | ForEach-Object {
        $columns = $_ -split '\s+'
        if ($columns.Count -ge 6) {
            [PSCustomObject]@{
                "Proto" = $columns[0]
                "Recv-Q" = $columns[1]
                "Send-Q" = $columns[2]
                "Local Address" = $columns[3]
                "Foreign Address" = $columns[4]
                "State" = $columns[5]
            }
        }
    } | Format-Table -AutoSize
    Write-Output $networkActivity

    Write-Host "`n[+] Grabbing current routing information..."
    $routeNetworkActivity = route -n | Select-String -Pattern '(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\S+)' | ForEach-Object {
        $matches = $_.Matches[0].Groups
        [PSCustomObject]@{
            "Destination" = $matches[1].Value
            "Gateway" = $matches[2].Value
            "Genmask" = $matches[3].Value
            "Flags" = $matches[4].Value
            "Metric" = $matches[5].Value
            "Ref" = $matches[6].Value
            "Use" = $matches[7].Value
            "Iface" = $matches[8].Value
        }
    } | Format-Table -AutoSize
    Write-Output $routeNetworkActivity
}

# Define the function to check for currently logged-in users
function Get-LoggedInUsers {
    $loggedInUsers = who
    Write-Host "`n[+] Currently Logged-In Users:"
    Write-Host $loggedInUsers
}

# Define the function to check if Antivirus is currently installed
function Check-AVInstalled {
    $avPackages = "clamav", "clamav-daemon", "clamtk", "trellix", "wazuh", "mdatp", "mdatp-*"
    $installedPackages = dpkg-query -W -f='${Package}\n'
    $avInstalled = $avPackages | ForEach-Object { $installedPackages -contains $_ }
    if ($avInstalled -contains $true) {
        Write-Host "`n[+] Antivirus software is installed on the system."
    } else {
        Write-Host "`n[+] Antivirus software is not installed on the system."
    }
}

function Check-CredentialManagerInstalled {
    $credentialManagers = "gnome-keyring", "kwalletmanager", "pass", "seahorse"
    $installed = $credentialManagers | ForEach-Object { which $_ }
    $installedManagers = $installed -ne $null
    if ($installedManagers) {
        Write-Host "`n[+] Credential management tools are installed on the system."
    } else {
        Write-Host "`n[+] Credential management tools are not installed on the system."
    }
}

# Function to search for .ps1 files on the target
function Search-PS1Files {
    Write-Host "Searching for .ps1 files in all directories..."

    $ErrorActionPreference = 'SilentlyContinue'

    $ps1Files = Get-ChildItem -Path / -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue

    $searchResults = @()

    if ($ps1Files) {
        $totalFiles = $ps1Files.Count

        # Display progress bar
        Write-Progress -Activity "Searching .ps1 files" -Status "Progress:" -PercentComplete 0 -SecondsRemaining -1

        foreach ($file in $ps1Files) {
            # Process each .ps1 file
            $searchResults += $file.FullName
        }

        Write-Progress -Activity "Searching .ps1 files" -Status "Complete" -PercentComplete 100
    } else {
        Write-Host "No .ps1 files found."
    }

    $ErrorActionPreference = 'Continue'

    # Output the search results
    $searchResults
}

function Search-AWSCredentials {
    Write-Host "`n[+] Searching for AWS credentials on the system..."

    $ErrorActionPreference = 'SilentlyContinue'

    # Common paths where AWS credentials might be stored
    $pathsToSearch = @(
        "$HOME/.aws/credentials",
        "$HOME/.aws/config"
    )

    # Search for credentials in common paths
    foreach ($path in $pathsToSearch) {
        if (Test-Path $path) {
            Write-Host "`nChecking $path for AWS credentials..."
            $content = Get-Content $path

            $awsAccessKeys = $content | Select-String -Pattern 'aws_access_key_id'
            $awsSecretKeys = $content | Select-String -Pattern 'aws_secret_access_key'
            $awsSessionTokens = $content | Select-String -Pattern 'aws_session_token'

            if ($awsAccessKeys) {
                Write-Host "`nAWS Access Keys found in $path"
                $awsAccessKeys | ForEach-Object { Write-Host $_.Line }
            }

            if ($awsSecretKeys) {
                Write-Host "`nAWS Secret Keys found in $path"
                $awsSecretKeys | ForEach-Object { Write-Host $_.Line }
            }

            if ($awsSessionTokens) {
                Write-Host "`nAWS Session Tokens found in $path"
                $awsSessionTokens | ForEach-Object { Write-Host $_.Line }
            }
        } else {
            Write-Host "$path not found."
        }
    }

    # Search for credentials in environment variables
    $awsEnvVars = Get-ChildItem Env: | Where-Object { $_.Name -match 'AWS_' }
    if ($awsEnvVars) {
        Write-Host "`nAWS credentials found in environment variables:"
        $awsEnvVars | Format-Table -AutoSize Name, Value
    }

    $ErrorActionPreference = 'Continue'
}

function Search-AzureCredentials {
    Write-Host "`n[+] Searching for Azure credentials on the system..."
    $azureCredentialsPath = "$HOME/.azure/credentials"

    if (Test-Path $azureCredentialsPath) {
        $azureCredentials = Get-Content $azureCredentialsPath
        Write-Host "`nAzure credentials found:"
        $azureCredentials | ForEach-Object { Write-Host $_ }
    } else {
        Write-Host "`nAzure credentials not found."
    }
}

function Review-UserHistory {
    Write-Host "`n[+] Reviewing user history..."
    $userHistory = Get-Content ~/.bash_history
    Write-Host "`n[+] User Command History:"
    $userHistory | ForEach-Object { Write-Host $_ }
}

function Review-PShistory {
    Write-Host "`n[+] Reviewing user PowerShell history..."
    $userPSHistory = Get-History
    Write-Host "`n[+] Users Powershell Command History:"
    $userPSHistory | ForEach-Object { Write-Host $_ }
}

function Check-Programs {
    $programs = @("nmap", "netcat", "curl", "wget", "ssh", "ftp", "gcc", "g++", "make", "python", "ruby", "perl")
    Write-Host "`n[+] Checking for installed programs..."
    foreach ($program in $programs) {
        if (Get-Command $program -ErrorAction SilentlyContinue) {
            Write-Host "[+] $program is installed."
        } else {
            Write-Host "[-] $program is not installed."
        }
    }
}

# Function to handle multiple command executions
function Execute-Commands {
    param (
        [string[]]$commands
    )
    foreach ($command in $commands) {
        if (Get-Command $command -ErrorAction SilentlyContinue) {
            Invoke-Expression $command
        } else {
            Write-Host "`n[!] Unknown command: $command"
        }
    }
}

# Main Execution using $args to pass multiple commands
if ($args.Count -eq 0) {
    Write-Host "`n[!] No commands specified. Use './script.ps1 Show-Help' for available options."
} else {
    Execute-Commands -commands $args
}
